-- Script: plsql_practical_workshop_robust_error_management.sql
-- Session: 054 - Practical Workshop #5 (Robust Error Management)
-- Purpose:
--   End-to-end hands-on lab combining all exception concepts:
--   1) Central -20xxx policy package with formatting helper
--   2) Error logging table + printing helpers
--   3) Inner modules that raise errors; boundary modules that log + translate
--   4) Transaction guard using SAVEPOINT/ROLLBACK
--   5) Comprehensive test harness invoking success + failure paths
-- How to run:
--   SET SERVEROUTPUT ON SIZE UNLIMITED;
--   Execute each block separately (terminated by '/').
-- Notes:
--   • Messages must include identifiers/parameters for faster debugging
--   • Never translate deep inside; translate only at interfaces (boundary)
--   • Keep logic idempotent: drop/create objects defensively when needed

SET SERVEROUTPUT ON SIZE UNLIMITED;

--------------------------------------------------------------------------------
-- A) Idempotent Setup: Core Tables Used Across Scenarios
--    We create a simple ORDERS table and a LOG table to persist diagnostics.
--------------------------------------------------------------------------------
BEGIN EXECUTE IMMEDIATE 'DROP TABLE pw5_orders PURGE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
CREATE TABLE pw5_orders(
  order_id   NUMBER CONSTRAINT pw5_orders_pk PRIMARY KEY,
  customer   VARCHAR2(80) NOT NULL,
  amount     NUMBER(12,2) NOT NULL,
  status     VARCHAR2(20) DEFAULT 'NEW' NOT NULL
);
/
INSERT INTO pw5_orders VALUES (1,'Avi', 500,'NEW');
INSERT INTO pw5_orders VALUES (2,'Neha',900,'PAID');
COMMIT;
/

BEGIN EXECUTE IMMEDIATE 'DROP TABLE pw5_error_log PURGE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
CREATE TABLE pw5_error_log(
  id            NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  logged_at     TIMESTAMP DEFAULT SYSTIMESTAMP NOT NULL,
  tag           VARCHAR2(50),
  err_code      NUMBER,
  err_stack     CLOB,
  err_backtrace CLOB,
  call_stack    CLOB
);
/
-- Rationale:
--   • Using IDENTITY for simplicity (Oracle 12c+)
--   • CLOB columns to store full diagnostics for later review

--------------------------------------------------------------------------------
-- B) Central Error Policy Package
--    Single source of truth for codes + message formatting + raise wrapper.
--------------------------------------------------------------------------------
CREATE OR REPLACE PACKAGE pw5_errors AS
  -- Application-visible domain codes (-20xxx)
  c_neg_amount       CONSTANT PLS_INTEGER := -20071;
  c_not_found        CONSTANT PLS_INTEGER := -20072;
  c_already_paid     CONSTANT PLS_INTEGER := -20073;
  c_invalid_status   CONSTANT PLS_INTEGER := -20074;
  c_generic          CONSTANT PLS_INTEGER := -20079;

  FUNCTION fmt(p_key VARCHAR2, p_msg VARCHAR2) RETURN VARCHAR2;
  PROCEDURE raise_err(p_code IN PLS_INTEGER, p_msg IN VARCHAR2);
END pw5_errors;
/
CREATE OR REPLACE PACKAGE BODY pw5_errors AS
  FUNCTION fmt(p_key VARCHAR2, p_msg VARCHAR2) RETURN VARCHAR2 IS
  BEGIN
    -- Standardize: '[KEY] message text with context'
    RETURN '['||p_key||'] '||p_msg;
  END;
  PROCEDURE raise_err(p_code IN PLS_INTEGER, p_msg IN VARCHAR2) IS
  BEGIN
    -- Wrap RAISE_APPLICATION_ERROR to centralize behavior
    RAISE_APPLICATION_ERROR(p_code, p_msg);
  END;
END pw5_errors;
/
SHOW ERRORS

--------------------------------------------------------------------------------
-- C) Printing + Persisting Diagnostics Helpers
--------------------------------------------------------------------------------
CREATE OR REPLACE PROCEDURE pw5_print_diag(p_tag IN VARCHAR2) IS
BEGIN
  DBMS_OUTPUT.PUT_LINE('--- '||p_tag||' ---');
  DBMS_OUTPUT.PUT_LINE('SQLCODE='||SQLCODE);
  DBMS_OUTPUT.PUT_LINE('STACK='||CHR(10)||DBMS_UTILITY.FORMAT_ERROR_STACK);
  DBMS_OUTPUT.PUT_LINE('BACKTRACE='||CHR(10)||DBMS_UTILITY.FORMAT_ERROR_BACKTRACE);
  DBMS_OUTPUT.PUT_LINE('CALL_STACK='||CHR(10)||DBMS_UTILITY.FORMAT_CALL_STACK);
END;
/
SHOW ERRORS

CREATE OR REPLACE PROCEDURE pw5_log_diag(p_tag IN VARCHAR2) IS
BEGIN
  INSERT INTO pw5_error_log(tag, err_code, err_stack, err_backtrace, call_stack)
  VALUES (
    p_tag,
    SQLCODE,
    DBMS_UTILITY.FORMAT_ERROR_STACK,
    DBMS_UTILITY.FORMAT_ERROR_BACKTRACE,
    DBMS_UTILITY.FORMAT_CALL_STACK
  );
  COMMIT;
END;
/
SHOW ERRORS

--------------------------------------------------------------------------------
-- D) Inner Logic Units (NO translation here): they raise named/system exceptions.
--------------------------------------------------------------------------------
CREATE OR REPLACE PACKAGE pw5_inner AS
  ex_neg_amount EXCEPTION; -- local named exception for internal signaling
  PROCEDURE set_amount(p_order_id IN NUMBER, p_amount IN NUMBER);
  PROCEDURE divide_fail; -- forces ZERO_DIVIDE to study stacks
END pw5_inner;
/
CREATE OR REPLACE PACKAGE BODY pw5_inner AS
  PROCEDURE set_amount(p_order_id IN NUMBER, p_amount IN NUMBER) IS
    v_dummy NUMBER;
  BEGIN
    -- Validate input: negative or zero amounts are illegal
    IF p_amount <= 0 THEN
      RAISE ex_neg_amount;
    END IF;

    -- Ensure row exists; SELECT INTO to fire NO_DATA_FOUND if missing
    SELECT 1 INTO v_dummy FROM pw5_orders WHERE order_id = p_order_id;

    UPDATE pw5_orders SET amount = p_amount WHERE order_id = p_order_id;
    -- No translation here; normal flow ends without exceptions
  END;

  PROCEDURE divide_fail IS
    v_num NUMBER := 1;
    v_den NUMBER := 0;
    v_res NUMBER;
  BEGIN
    -- Forcing ZERO_DIVIDE (ORA-01476) to observe diagnostic outputs
    v_res := v_num / v_den;
  END;
END pw5_inner;
/
SHOW ERRORS

--------------------------------------------------------------------------------
-- E) Boundary Layer (Translation + Transaction Guard + Logging)
--    These procedures catch everything, log, then translate to -20xxx.
--------------------------------------------------------------------------------
CREATE OR REPLACE PACKAGE pw5_boundary AS
  PROCEDURE api_set_amount(p_order_id IN NUMBER, p_amount IN NUMBER);
  PROCEDURE api_payment(p_order_id IN NUMBER);
  PROCEDURE api_compute; -- calls inner divide_fail and translates
END pw5_boundary;
/
CREATE OR REPLACE PACKAGE BODY pw5_boundary AS
  PROCEDURE api_set_amount(p_order_id IN NUMBER, p_amount IN NUMBER) IS
  BEGIN
    -- Boundary: Guard with SAVEPOINT so partial DML can be reverted safely
    SAVEPOINT sp_set_amount;

    -- Call inner unit that might raise named/system exceptions
    pw5_inner.set_amount(p_order_id => p_order_id, p_amount => p_amount);

    COMMIT; -- Success path
  EXCEPTION
    WHEN pw5_inner.ex_neg_amount THEN
      -- Log + translate for client with stable code and context
      pw5_print_diag('API_SET_AMOUNT_NEG');
      pw5_log_diag('API_SET_AMOUNT_NEG');
      pw5_errors.raise_err(
        pw5_errors.c_neg_amount,
        pw5_errors.fmt('PW5-SET-NEG','Amount must be positive. id='||p_order_id||' amt='||p_amount)
      );
    WHEN NO_DATA_FOUND THEN
      pw5_print_diag('API_SET_AMOUNT_NF');
      pw5_log_diag('API_SET_AMOUNT_NF');
      pw5_errors.raise_err(
        pw5_errors.c_not_found,
        pw5_errors.fmt('PW5-SET-404','Order not found. id='||p_order_id)
      );
    WHEN OTHERS THEN
      -- Rollback this small unit and translate to generic
      ROLLBACK TO sp_set_amount;
      pw5_print_diag('API_SET_AMOUNT_OTHERS');
      pw5_log_diag('API_SET_AMOUNT_OTHERS');
      pw5_errors.raise_err(
        pw5_errors.c_generic,
        pw5_errors.fmt('PW5-SET-GEN','Unexpected error. id='||p_order_id||' cause='||SQLERRM)
      );
  END;

  PROCEDURE api_payment(p_order_id IN NUMBER) IS
    v_status pw5_orders.status%TYPE;
  BEGIN
    -- Basic check + translation paths
    SELECT status INTO v_status FROM pw5_orders WHERE order_id = p_order_id;

    IF v_status = 'PAID' THEN
      pw5_errors.raise_err(
        pw5_errors.c_already_paid,
        pw5_errors.fmt('PW5-PAY-001','Order already PAID. id='||p_order_id)
      );
    END IF;

    UPDATE pw5_orders SET status = 'PAID' WHERE order_id = p_order_id;
    COMMIT;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      pw5_print_diag('API_PAY_NF');
      pw5_log_diag('API_PAY_NF');
      pw5_errors.raise_err(
        pw5_errors.c_not_found,
        pw5_errors.fmt('PW5-PAY-404','Order not found. id='||p_order_id)
      );
    WHEN OTHERS THEN
      pw5_print_diag('API_PAY_OTHERS');
      pw5_log_diag('API_PAY_OTHERS');
      pw5_errors.raise_err(
        pw5_errors.c_generic,
        pw5_errors.fmt('PW5-PAY-GEN','Unexpected error. id='||p_order_id||' cause='||SQLERRM)
      );
  END;

  PROCEDURE api_compute IS
  BEGIN
    pw5_inner.divide_fail; -- triggers ZERO_DIVIDE
  EXCEPTION
    WHEN OTHERS THEN
      pw5_print_diag('API_COMPUTE_FAIL');
      pw5_log_diag('API_COMPUTE_FAIL');
      pw5_errors.raise_err(
        pw5_errors.c_generic,
        pw5_errors.fmt('PW5-COMP-GEN','Computation failed. cause='||SQLERRM)
      );
  END;
END pw5_boundary;
/
SHOW ERRORS

--------------------------------------------------------------------------------
-- F) Test Harness: Verify success + each failure path and their codes/messages
--    Each block below is independent. Execute them one by one.
--------------------------------------------------------------------------------

-- 1) Success: set positive amount
BEGIN
  pw5_boundary.api_set_amount(1, 750);
  DBMS_OUTPUT.PUT_LINE('OK: updated amount for id=1');
END;
/
-- 2) Failure: negative amount -> c_neg_amount (-20071)
BEGIN
  pw5_boundary.api_set_amount(1, -5);
EXCEPTION WHEN OTHERS THEN
  DBMS_OUTPUT.PUT_LINE('[NEG] code='||SQLCODE||' msg='||SQLERRM);
END;
/
-- 3) Failure: not found -> c_not_found (-20072)
BEGIN
  pw5_boundary.api_set_amount(999, 100);
EXCEPTION WHEN OTHERS THEN
  DBMS_OUTPUT.PUT_LINE('[NF] code='||SQLCODE||' msg='||SQLERRM);
END;
/
-- 4) Success then duplicate pay -> c_already_paid (-20073)
BEGIN
  pw5_boundary.api_payment(1);
  BEGIN pw5_boundary.api_payment(1); EXCEPTION WHEN OTHERS THEN DBMS_OUTPUT.PUT_LINE('[DUP] code='||SQLCODE||' msg='||SQLERRM); END;
END;
/
-- 5) Not found on pay -> c_not_found (-20072)
BEGIN
  pw5_boundary.api_payment(999);
EXCEPTION WHEN OTHERS THEN
  DBMS_OUTPUT.PUT_LINE('[PAY-NF] code='||SQLCODE||' msg='||SQLERRM);
END;
/
-- 6) Inner compute error -> c_generic (-20079) with stack/backtrace logged
BEGIN
  pw5_boundary.api_compute;
EXCEPTION WHEN OTHERS THEN
  DBMS_OUTPUT.PUT_LINE('[COMP] code='||SQLCODE||' msg='||SQLERRM);
END;
/
-- 7) Inspect log records
SET PAGESIZE 200
COLUMN tag FORMAT A24
SELECT tag, err_code, SUBSTR(err_stack,1,80) AS stack_sample FROM pw5_error_log ORDER BY id;
/
--------------------------------------------------------------------------------
-- End of File
--------------------------------------------------------------------------------
