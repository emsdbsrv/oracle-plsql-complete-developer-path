SET SERVEROUTPUT ON SIZE UNLIMITED;
--------------------------------------------------------------------------------
-- Session: 068 – Bulk Record Operations
-- Purpose:
--   Demonstrate high-throughput bulk techniques using PL/SQL RECORDs:
--   BULK COLLECT, FORALL, SAVE EXCEPTIONS, LIMIT batching, and error logging.
--
-- Data:
--   Uses rt_orders as the base table. Adds rt_orders_log for batch error/audit.
--
-- How to run:
--   Execute each block separately (terminated by '/'). Keep SERVEROUTPUT ON.
-- Notes:
--   • BULK COLLECT into a collection of %ROWTYPE or custom RECORD\n
--   • FORALL applies one DML statement to all indexed elements in a collection\n
--   • SAVE EXCEPTIONS defers errors; inspect SQL%BULK_EXCEPTIONS after FORALL
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 0) Bootstrap (idempotent): ensure base and log tables exist with seeds
--------------------------------------------------------------------------------
DECLARE
  n NUMBER;
BEGIN
  SELECT COUNT(*) INTO n FROM user_tables WHERE table_name='RT_ORDERS';
  IF n = 0 THEN
    EXECUTE IMMEDIATE 'CREATE TABLE rt_orders(
      order_id     NUMBER        CONSTRAINT rt_orders_pk PRIMARY KEY,
      customer_id  NUMBER        NOT NULL,
      item_name    VARCHAR2(100) NOT NULL,
      qty          NUMBER(10)    DEFAULT 1 CHECK (qty > 0),
      unit_price   NUMBER(12,2)  NOT NULL CHECK (unit_price >= 0),
      status       VARCHAR2(12)  DEFAULT ''NEW'' CHECK (status IN (''NEW'',''PAID'',''CANCELLED'')),
      created_at   DATE          DEFAULT SYSDATE NOT NULL
    )';
    EXECUTE IMMEDIATE 'INSERT INTO rt_orders VALUES (1001,1,''SSD 1TB'',1,6500,''NEW'',SYSDATE-5)';
    EXECUTE IMMEDIATE 'INSERT INTO rt_orders VALUES (1002,2,''Laptop'',1,55000,''PAID'',SYSDATE-2)';
    EXECUTE IMMEDIATE 'INSERT INTO rt_orders VALUES (1003,1,''USB-C Hub'',2,1200,''NEW'',SYSDATE-1)';
    EXECUTE IMMEDIATE 'COMMIT';
  END IF;

  SELECT COUNT(*) INTO n FROM user_tables WHERE table_name='RT_ORDERS_LOG';
  IF n = 0 THEN
    EXECUTE IMMEDIATE 'CREATE TABLE rt_orders_log(
      log_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
      order_id   NUMBER,
      action     VARCHAR2(30),
      msg        VARCHAR2(4000),
      created_at DATE DEFAULT SYSDATE
    )';
  END IF;
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 1) BULK COLLECT into table%ROWTYPE collection
--    Scenario: Load all NEW orders into memory in one shot.
--------------------------------------------------------------------------------
DECLARE
  TYPE t_rows IS TABLE OF rt_orders%ROWTYPE;
  v_rows t_rows;
BEGIN
  SELECT * BULK COLLECT INTO v_rows FROM rt_orders WHERE status='NEW' ORDER BY order_id;
  DBMS_OUTPUT.PUT_LINE('loaded rows='||v_rows.COUNT);
  IF v_rows.COUNT>0 THEN
    DBMS_OUTPUT.PUT_LINE('first='||v_rows(1).order_id||' '||v_rows(1).item_name);
  END IF;
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 2) BULK COLLECT with LIMIT batching
--    Scenario: Stream NEW orders in batches of 2 to control memory.
--------------------------------------------------------------------------------
DECLARE
  CURSOR c IS SELECT * FROM rt_orders WHERE status='NEW' ORDER BY order_id;
  TYPE t_rows IS TABLE OF c%ROWTYPE;
  v_rows t_rows;
  c_limit PLS_INTEGER := 2;
BEGIN
  OPEN c;
  LOOP
    FETCH c BULK COLLECT INTO v_rows LIMIT c_limit;
    EXIT WHEN v_rows.COUNT = 0;

    DBMS_OUTPUT.PUT_LINE('batch size='||v_rows.COUNT);
    -- process batch elements
    FOR i IN 1..v_rows.COUNT LOOP
      DBMS_OUTPUT.PUT_LINE('  order_id='||v_rows(i).order_id||' qty='||v_rows(i).qty);
    END LOOP;
  END LOOP;
  CLOSE c;
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 3) FORALL bulk UPDATE with SAVE EXCEPTIONS
--    Scenario: Increase qty by 1 for all NEW orders. If any fails, capture details.
--------------------------------------------------------------------------------
DECLARE
  TYPE t_ids IS TABLE OF rt_orders.order_id%TYPE INDEX BY PLS_INTEGER;
  v_ids t_ids;
  i PLS_INTEGER := 0;
BEGIN
  -- collect order ids to update
  FOR r IN (SELECT order_id FROM rt_orders WHERE status='NEW' ORDER BY order_id) LOOP
    i := i + 1;
    v_ids(i) := r.order_id;
  END LOOP;

  DBMS_OUTPUT.PUT_LINE('ids collected='||i);

  SAVEPOINT before_bulk;

  BEGIN
    FORALL idx IN v_ids.FIRST..v_ids.LAST SAVE EXCEPTIONS
      UPDATE rt_orders
         SET qty = NVL(qty,1)+1
       WHERE order_id = v_ids(idx);

  EXCEPTION
    WHEN OTHERS THEN
      DBMS_OUTPUT.PUT_LINE('bulk update exceptions='||SQL%BULK_EXCEPTIONS.COUNT);
      FOR j IN 1..SQL%BULK_EXCEPTIONS.COUNT LOOP
        INSERT INTO rt_orders_log(order_id, action, msg)
        VALUES (v_ids(SQL%BULK_EXCEPTIONS(j).error_index),
                'UPDATE_QTY',
                'errcode='||SQL%BULK_EXCEPTIONS(j).error_code||' at index='||SQL%BULK_EXCEPTIONS(j).error_index);
      END LOOP;
  END;

  COMMIT;
  DBMS_OUTPUT.PUT_LINE('bulk update done');
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 4) FORALL bulk INSERT into log using a RECORD collection
--    Scenario: Copy PAID orders into log with an action description.
--------------------------------------------------------------------------------
DECLARE
  TYPE t_log IS RECORD(order_id NUMBER, action VARCHAR2(30), msg VARCHAR2(200));
  TYPE t_logs IS TABLE OF t_log INDEX BY PLS_INTEGER;
  v t_logs; k PLS_INTEGER := 0;
BEGIN
  FOR r IN (SELECT order_id, item_name FROM rt_orders WHERE status='PAID' ORDER BY order_id) LOOP
    k := k + 1;
    v(k).order_id := r.order_id;
    v(k).action := 'AUDIT';
    v(k).msg := 'copied paid order '||r.item_name;
  END LOOP;

  IF v.COUNT > 0 THEN
    FORALL i IN v.FIRST..v.LAST
      INSERT INTO rt_orders_log(order_id, action, msg) VALUES (v(i).order_id, v(i).action, v(i).msg);
  END IF;

  COMMIT;
  DBMS_OUTPUT.PUT_LINE('inserted logs='||NVL(v.COUNT,0));
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 5) FORALL DELETE with id range and error capture
--    Scenario: Demonstrate batched delete for a non-existent range to show errors.
--------------------------------------------------------------------------------
DECLARE
  TYPE t_ids IS TABLE OF NUMBER INDEX BY PLS_INTEGER;
  v t_ids;
BEGIN
  v(1):=99991; v(2):=99992; v(3):=99993; -- likely absent ids
  BEGIN
    FORALL i IN v.FIRST..v.LAST SAVE EXCEPTIONS
      DELETE FROM rt_orders WHERE order_id = v(i);

  EXCEPTION WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('delete exceptions='||SQL%BULK_EXCEPTIONS.COUNT);
    FOR j IN 1..SQL%BULK_EXCEPTIONS.COUNT LOOP
      INSERT INTO rt_orders_log(order_id, action, msg)
      VALUES (v(SQL%BULK_EXCEPTIONS(j).error_index),
              'DELETE_ATTEMPT',
              'err='||SQL%BULK_EXCEPTIONS(j).error_code);
    END LOOP;
    COMMIT;
  END;
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- 6) End-to-end: BULK COLLECT LIMIT + FORALL UPDATE + logging
--    Scenario: Process NEW orders in batches of 2, set status to PAID, and log.
--------------------------------------------------------------------------------
DECLARE
  CURSOR c IS SELECT order_id FROM rt_orders WHERE status='NEW' ORDER BY order_id;
  TYPE t_ids IS TABLE OF rt_orders.order_id%TYPE;
  v_ids t_ids;
BEGIN
  OPEN c;
  LOOP
    FETCH c BULK COLLECT INTO v_ids LIMIT 2;
    EXIT WHEN v_ids.COUNT=0;

    FORALL i IN 1..v_ids.COUNT
      UPDATE rt_orders SET status='PAID' WHERE order_id = v_ids(i);

    FOR i IN 1..v_ids.COUNT LOOP
      INSERT INTO rt_orders_log(order_id, action, msg) VALUES (v_ids(i), 'STATUS_CHANGE', 'NEW->PAID in batch');
    END LOOP;

    COMMIT;
  END LOOP;
  CLOSE c;
  DBMS_OUTPUT.PUT_LINE('end-to-end batch status updates complete');
END;
/
--------------------------------------------------------------------------------

-- End of Lesson File
