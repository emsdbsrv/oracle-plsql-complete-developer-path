-- Script: plsql_record_modification_operations.sql
-- Session: 032 - Record Modification Operations (Production Patterns)
-- Purpose:
--   Demonstrate robust UPDATE and MERGE patterns with line-by-line commentary:
--   (1) Targeted UPDATE + RETURNING INTO
--   (2) UPDATE with optimistic locking (version column)
--   (3) UPDATE with correlated subquery
--   (4) Cursor UPDATE with WHERE CURRENT OF
--   (5) MERGE (upsert) - update when matched, insert when not
--   (6) MERGE with conditional clauses and audit insert
--   (7) Bulk FORALL UPDATE with SAVE EXCEPTIONS
--   (8) SAVEPOINT + ROLLBACK for partial failure handling
-- How to run:
--   SET SERVEROUTPUT ON; Execute each block separately (terminated by '/').
-- Notes:
--   • Anchor types with %TYPE / %ROWTYPE to follow schema evolution.
--   • Always print SQL%%ROWCOUNT after DML to verify affected rows.

SET SERVEROUTPUT ON;

--------------------------------------------------------------------------------
-- Setup (idempotent) – base tables for this session
--------------------------------------------------------------------------------
BEGIN EXECUTE IMMEDIATE 'DROP TABLE dept_mod PURGE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TABLE emp_mod PURGE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
BEGIN EXECUTE IMMEDIATE 'DROP TABLE emp_mod_audit PURGE'; EXCEPTION WHEN OTHERS THEN NULL; END;
/
CREATE TABLE dept_mod (
  dept_id      NUMBER       PRIMARY KEY,
  dept_name    VARCHAR2(50) NOT NULL,
  last_updated DATE         DEFAULT SYSDATE
);
CREATE TABLE emp_mod (
  emp_id        NUMBER       PRIMARY KEY,
  emp_name      VARCHAR2(50) NOT NULL,
  dept_id       NUMBER       REFERENCES dept_mod(dept_id),
  salary        NUMBER(10,2),
  email         VARCHAR2(120),
  version_no    NUMBER       DEFAULT 1,         -- optimistic lock
  last_updated  DATE         DEFAULT SYSDATE
);
CREATE TABLE emp_mod_audit (
  audit_id      NUMBER GENERATED BY DEFAULT AS IDENTITY,
  emp_id        NUMBER,
  action        VARCHAR2(20),
  old_salary    NUMBER(10,2),
  new_salary    NUMBER(10,2),
  note          VARCHAR2(200),
  created_on    DATE DEFAULT SYSDATE
);
INSERT INTO dept_mod VALUES (10,'Engineering', SYSDATE);
INSERT INTO dept_mod VALUES (20,'Finance',     SYSDATE);
INSERT INTO emp_mod(emp_id, emp_name, dept_id, salary, email) VALUES (1,'Avi', 10, 90000,'avi@example.com');
INSERT INTO emp_mod(emp_id, emp_name, dept_id, salary, email) VALUES (2,'Raj', 10, 80000,'raj@example.com');
INSERT INTO emp_mod(emp_id, emp_name, dept_id, salary, email) VALUES (3,'Mani',20, 75000,'mani@example.com');
COMMIT;
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Example 1: Targeted UPDATE + RETURNING INTO
-- Scenario:
--   Increase Mani's salary by 750 and capture the new value immediately.
-- Expected Output:
--   'rows=1; new_salary=<value>'
--------------------------------------------------------------------------------
DECLARE
  v_new emp_mod.salary%TYPE;
BEGIN
  UPDATE emp_mod
  SET    salary = salary + 750,
         last_updated = SYSDATE
  WHERE  emp_id = 3
  RETURNING salary INTO v_new;
  DBMS_OUTPUT.PUT_LINE('rows='||SQL%ROWCOUNT||'; new_salary='||v_new);
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Example 2: UPDATE with optimistic locking (version check)
-- Scenario:
--   Prevent lost updates by verifying version_no in the WHERE clause, then bump it.
-- Expected Output:
--   'updated with version check rows=1' or 'concurrency conflict'
--------------------------------------------------------------------------------
DECLARE
  v_expected_version emp_mod.version_no%TYPE;
BEGIN
  SELECT version_no INTO v_expected_version FROM emp_mod WHERE emp_id=2;
  -- Simulate another process? (not here). Proceed with check:
  UPDATE emp_mod
  SET    salary = salary + 500,
         version_no = version_no + 1,
         last_updated = SYSDATE
  WHERE  emp_id = 2
  AND    version_no = v_expected_version;

  IF SQL%ROWCOUNT = 1 THEN
    DBMS_OUTPUT.PUT_LINE('updated with version check rows=1');
  ELSE
    DBMS_OUTPUT.PUT_LINE('concurrency conflict');
  END IF;
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Example 3: UPDATE with correlated subquery
-- Scenario:
--   Give 5% raise to all in Engineering (dept_id=10) using correlated subquery.
-- Expected Output:
--   'dept 10 raise rows=<count>'
--------------------------------------------------------------------------------
BEGIN
  UPDATE emp_mod e
  SET    e.salary = ROUND(e.salary * 1.05, 2),
         e.last_updated = SYSDATE
  WHERE  e.dept_id = (SELECT d.dept_id FROM dept_mod d WHERE d.dept_id = 10);
  DBMS_OUTPUT.PUT_LINE('dept 10 raise rows='||SQL%ROWCOUNT);
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Example 4: Cursor UPDATE with WHERE CURRENT OF
-- Scenario:
--   Iterate Finance employees and append '-fin' to email using a FOR UPDATE cursor.
-- Expected Output:
--   Prints updated emails; SQL%%ROWCOUNT not available within cursor updates,
--   so we count manually.
--------------------------------------------------------------------------------
DECLARE
  CURSOR c_fin IS
    SELECT emp_id, email FROM emp_mod
    WHERE dept_id=20
    FOR UPDATE OF email NOWAIT;
  v_count PLS_INTEGER := 0;
BEGIN
  FOR r IN c_fin LOOP
    UPDATE emp_mod
    SET email = r.email || '-fin',
        last_updated = SYSDATE
    WHERE CURRENT OF c_fin;
    v_count := v_count + 1;
  END LOOP;
  DBMS_OUTPUT.PUT_LINE('finance email updates='||v_count);
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Example 5: MERGE (upsert) - update when matched, insert when not matched
-- Scenario:
--   Upsert a list of (emp_id, name, dept, salary); update salary if exists, insert if not.
-- Expected Output:
--   MERGE reports total processed via SQL%%ROWCOUNT (rows inserted + rows updated).
--------------------------------------------------------------------------------
BEGIN
  MERGE INTO emp_mod t
  USING (
    SELECT 2 AS emp_id, 'Raj'  AS emp_name, 10 AS dept_id, 82000 AS salary FROM dual UNION ALL
    SELECT 4 AS emp_id, 'Neha' AS emp_name, 20 AS dept_id, 70000 AS salary FROM dual
  ) s
  ON (t.emp_id = s.emp_id)
  WHEN MATCHED THEN
    UPDATE SET t.salary = s.salary, t.last_updated = SYSDATE
  WHEN NOT MATCHED THEN
    INSERT (emp_id, emp_name, dept_id, salary, email, version_no, last_updated)
    VALUES (s.emp_id, s.emp_name, s.dept_id, s.salary, LOWER(s.emp_name)||'@example.com', 1, SYSDATE);

  DBMS_OUTPUT.PUT_LINE('merge rows='||SQL%ROWCOUNT);
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Example 6: MERGE with conditional clauses and audit insert
-- Scenario:
--   Raise Engineering by 3% (matched); insert an audit record for each updated row.
--   We do audit in a second statement to keep MERGE set-based and simple.
-- Expected Output:
--   Prints count of audited rows.
--------------------------------------------------------------------------------
DECLARE
  v_before NUMBER;
  v_after  NUMBER;
  v_audited PLS_INTEGER := 0;
BEGIN
  -- Capture totals before
  SELECT SUM(salary) INTO v_before FROM emp_mod WHERE dept_id=10;

  MERGE INTO emp_mod t
  USING (SELECT emp_id, salary FROM emp_mod WHERE dept_id=10) s
  ON (t.emp_id = s.emp_id)
  WHEN MATCHED THEN
    UPDATE SET t.salary = ROUND(s.salary * 1.03, 2),
               t.last_updated = SYSDATE;

  -- Audit differences
  FOR r IN (
    SELECT e.emp_id, e.salary AS new_salary, a.old_salary
    FROM   emp_mod e
    JOIN   (
      SELECT emp_id, ROUND(salary/1.03,2) AS old_salary FROM emp_mod WHERE dept_id=10
    ) a ON a.emp_id = e.emp_id
    WHERE e.dept_id=10
  ) LOOP
    INSERT INTO emp_mod_audit(emp_id, action, old_salary, new_salary, note)
    VALUES (r.emp_id, 'RAISE', r.old_salary, r.new_salary, 'MERGE-3pct');
    v_audited := v_audited + 1;
  END LOOP;

  SELECT SUM(salary) INTO v_after FROM emp_mod WHERE dept_id=10;
  DBMS_OUTPUT.PUT_LINE('audited rows='||v_audited||'; delta='||(v_after - v_before));
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Example 7: Bulk FORALL UPDATE with SAVE EXCEPTIONS
-- Scenario:
--   Update salaries in bulk from a collection; one bad key will be reported not abort.
-- Expected Output:
--   Prints number of bulk exceptions encountered.
--------------------------------------------------------------------------------
DECLARE
  TYPE t_upd IS TABLE OF emp_mod%ROWTYPE;
  v_rows t_upd := t_upd();
  errors EXCEPTION; PRAGMA EXCEPTION_INIT(errors, -24381);
BEGIN
  v_rows.EXTEND(3);
  v_rows(1).emp_id := 1; v_rows(1).salary := 91000;
  v_rows(2).emp_id := 99; v_rows(2).salary := 60000; -- non-existent, will fail
  v_rows(3).emp_id := 2; v_rows(3).salary := 83000;

  BEGIN
    FORALL i IN 1..v_rows.COUNT SAVE EXCEPTIONS
      UPDATE emp_mod
      SET    salary = v_rows(i).salary,
             last_updated = SYSDATE
      WHERE  emp_id = v_rows(i).emp_id;
  EXCEPTION
    WHEN errors THEN
      DBMS_OUTPUT.PUT_LINE('bulk exceptions='||SQL%BULK_EXCEPTIONS.COUNT);
  END;
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Example 8: SAVEPOINT + ROLLBACK for partial failure handling
-- Scenario:
--   Apply two updates; rollback the second on error but keep the first via SAVEPOINT.
-- Expected Output:
--   'first applied' then 'second rolled back' message.
--------------------------------------------------------------------------------
DECLARE
  bad_id emp_mod.emp_id%TYPE := 999; -- will not exist
BEGIN
  SAVEPOINT before_first;
  UPDATE emp_mod SET salary = salary + 100 WHERE emp_id = 1;
  DBMS_OUTPUT.PUT_LINE('first applied rows='||SQL%ROWCOUNT);

  SAVEPOINT before_second;
  BEGIN
    UPDATE emp_mod SET salary = salary + 100 WHERE emp_id = bad_id; -- 0 rows
    IF SQL%ROWCOUNT = 0 THEN
      ROLLBACK TO before_second;
      DBMS_OUTPUT.PUT_LINE('second rolled back (no rows matched)');
    END IF;
  END;

  COMMIT;
END;
/
--------------------------------------------------------------------------------
-- End of File
--------------------------------------------------------------------------------
