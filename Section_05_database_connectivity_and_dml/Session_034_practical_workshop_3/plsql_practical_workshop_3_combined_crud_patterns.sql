-- Script: plsql_practical_workshop_3_combined_crud_patterns.sql
-- Session: 034 - Practical Workshop #3 (Combined CRUD Patterns)
-- Purpose:
--   End-to-end CRUD flows on a mini Order Management domain with full commentary:
--   (1) Schema setup and seed data
--   (2) Create order with RETURNING and line inserts (transactional)
--   (3) Read/validate using SELECT; dry-run counts and EXISTS checks
--   (4) Update with optimistic locking (version) and audit
--   (5) MERGE-based upsert for product price updates
--   (6) Delete with archive-before-delete pattern
--   (7) Soft delete + purge window
--   (8) Bulk FORALL operations with SAVE EXCEPTIONS
-- How to run:
--   SET SERVEROUTPUT ON; Execute each block separately (terminated by '/').
-- AI note: AI assistance is optional per your policy; code is self-explanatory.
SET SERVEROUTPUT ON;

--------------------------------------------------------------------------------
-- (1) Setup â€“ drop and create schema objects (idempotent)
--------------------------------------------------------------------------------
BEGIN FOR t IN (SELECT table_name FROM user_tables WHERE table_name IN (
  'CUSTOMERS','PRODUCTS','ORDERS_HDR','ORDERS_LINE','ORDERS_ARCHIVE','AUDIT_LOG'
)) LOOP EXECUTE IMMEDIATE 'DROP TABLE '||t.table_name||' PURGE'; END LOOP; END;
/
CREATE TABLE customers (
  cust_id     NUMBER PRIMARY KEY,
  cust_name   VARCHAR2(80) NOT NULL,
  email       VARCHAR2(120),
  status      VARCHAR2(20) DEFAULT 'ACTIVE',
  created_on  DATE DEFAULT SYSDATE
);
CREATE TABLE products (
  sku         VARCHAR2(40) PRIMARY KEY,
  name        VARCHAR2(120) NOT NULL,
  price       NUMBER(10,2) NOT NULL,
  active      CHAR(1) DEFAULT 'Y',
  version_no  NUMBER DEFAULT 1,
  last_updated DATE DEFAULT SYSDATE
);
CREATE TABLE orders_hdr (
  order_id    NUMBER PRIMARY KEY,
  cust_id     NUMBER REFERENCES customers(cust_id),
  order_status VARCHAR2(20) DEFAULT 'NEW',
  grand_total NUMBER(12,2) DEFAULT 0,
  version_no  NUMBER DEFAULT 1,
  created_on  DATE DEFAULT SYSDATE,
  last_updated DATE DEFAULT SYSDATE,
  is_deleted  CHAR(1) DEFAULT 'N',
  deleted_on  DATE
);
CREATE TABLE orders_line (
  line_id     NUMBER PRIMARY KEY,
  order_id    NUMBER REFERENCES orders_hdr(order_id) ON DELETE CASCADE,
  sku         VARCHAR2(40) REFERENCES products(sku),
  qty         NUMBER NOT NULL,
  price_each  NUMBER(10,2) NOT NULL,
  line_total  NUMBER(12,2) NOT NULL
);
CREATE TABLE orders_archive AS SELECT * FROM orders_hdr WHERE 1=0;
CREATE TABLE audit_log (
  audit_id    NUMBER GENERATED BY DEFAULT AS IDENTITY,
  entity      VARCHAR2(30),
  entity_id   VARCHAR2(60),
  action      VARCHAR2(20),
  details     VARCHAR2(4000),
  created_on  DATE DEFAULT SYSDATE
);

INSERT INTO customers VALUES (1,'Avi','avi@example.com','ACTIVE',SYSDATE);
INSERT INTO customers VALUES (2,'Raj','raj@example.com','ACTIVE',SYSDATE);

INSERT INTO products(sku,name,price) VALUES ('SKU-1','USB Cable',300);
INSERT INTO products(sku,name,price) VALUES ('SKU-2','Mouse',800);
INSERT INTO products(sku,name,price) VALUES ('SKU-3','Keyboard',1500);

COMMIT;
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- (2) Create order with RETURNING; insert lines; compute totals atomically
--------------------------------------------------------------------------------
DECLARE
  v_order_id orders_hdr.order_id%TYPE;
BEGIN
  -- Create header and get id via RETURNING (simulate sequence with manual value)
  v_order_id := 1001;
  INSERT INTO orders_hdr(order_id, cust_id, order_status, grand_total)
  VALUES (v_order_id, 1, 'NEW', 0);
  DBMS_OUTPUT.PUT_LINE('order created id='||v_order_id);

  -- Insert lines from a derived list (2 items); compute line_total from products
  INSERT INTO orders_line(line_id, order_id, sku, qty, price_each, line_total)
  SELECT 10011, v_order_id, 'SKU-1', 2, p.price, p.price*2 FROM products p WHERE p.sku='SKU-1';
  INSERT INTO orders_line(line_id, order_id, sku, qty, price_each, line_total)
  SELECT 10012, v_order_id, 'SKU-2', 1, p.price, p.price*1 FROM products p WHERE p.sku='SKU-2';

  -- Update header grand_total set-based
  UPDATE orders_hdr h
  SET    h.grand_total = (SELECT SUM(line_total) FROM orders_line l WHERE l.order_id=h.order_id),
         h.last_updated = SYSDATE
  WHERE  h.order_id = v_order_id;

  INSERT INTO audit_log(entity, entity_id, action, details)
  VALUES ('ORDER', TO_CHAR(v_order_id), 'CREATE', 'Created with 2 lines');
  COMMIT;
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- (3) Read/validate with SELECT (dry-runs and checks)
--------------------------------------------------------------------------------
DECLARE
  v_cnt NUMBER;
BEGIN
  SELECT COUNT(*) INTO v_cnt FROM orders_line WHERE order_id=1001;
  DBMS_OUTPUT.PUT_LINE('line count='||v_cnt);

  IF NOT EXISTS (SELECT 1 FROM orders_hdr WHERE order_id=1001 AND grand_total>0) THEN
    DBMS_OUTPUT.PUT_LINE('grand_total missing!');
  ELSE
    DBMS_OUTPUT.PUT_LINE('grand_total present.');
  END IF;
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- (4) Update with optimistic locking + audit
--------------------------------------------------------------------------------
DECLARE
  v_ver orders_hdr.version_no%TYPE;
BEGIN
  SELECT version_no INTO v_ver FROM orders_hdr WHERE order_id=1001 FOR UPDATE;
  UPDATE orders_hdr
  SET grand_total = grand_total + 50,
      version_no  = version_no + 1,
      last_updated= SYSDATE
  WHERE order_id=1001 AND version_no=v_ver;

  IF SQL%ROWCOUNT=1 THEN
    INSERT INTO audit_log(entity,entity_id,action,details)
    VALUES ('ORDER','1001','ADJUST','+50 adjustment with version check from '||v_ver);
  ELSE
    DBMS_OUTPUT.PUT_LINE('Concurrency conflict on order 1001');
  END IF;
  COMMIT;
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- (5) MERGE upsert for product price updates
--------------------------------------------------------------------------------
BEGIN
  MERGE INTO products t
  USING (SELECT 'SKU-2' sku, 875 price FROM dual UNION ALL
                SELECT 'SKU-4' sku, 1200 price FROM dual) s
  ON (t.sku=s.sku)
  WHEN MATCHED THEN UPDATE SET t.price=s.price, t.version_no=t.version_no+1, t.last_updated=SYSDATE
  WHEN NOT MATCHED THEN INSERT (sku,name,price,active,version_no,last_updated)
       VALUES (s.sku, 'New Product', s.price, 'Y', 1, SYSDATE);
  DBMS_OUTPUT.PUT_LINE('merge products rows='||SQL%ROWCOUNT);
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- (6) Delete with archive-before-delete (old completed orders)
--------------------------------------------------------------------------------
DECLARE
  v_arch NUMBER;
  v_del  NUMBER;
BEGIN
  INSERT INTO orders_archive
  SELECT * FROM orders_hdr WHERE order_status='COMPLETED' AND created_on < SYSDATE-60;
  v_arch := SQL%ROWCOUNT;

  DELETE FROM orders_hdr
  WHERE order_status='COMPLETED' AND created_on < SYSDATE-60;
  v_del := SQL%ROWCOUNT;

  INSERT INTO audit_log(entity,entity_id,action,details)
  VALUES ('ORDER','*','ARCHIVE_DELETE','archived='||v_arch||'; deleted='||v_del);
  COMMIT;
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- (7) Soft delete + purge window
--------------------------------------------------------------------------------
BEGIN
  UPDATE orders_hdr SET is_deleted='Y', deleted_on=SYSDATE WHERE order_id=1001;
  DBMS_OUTPUT.PUT_LINE('soft delete rows='||SQL%ROWCOUNT);

  -- simulate passage of time by subtracting days
  UPDATE orders_hdr SET deleted_on = SYSDATE-31 WHERE order_id=1001;
  DELETE FROM orders_hdr WHERE is_deleted='Y' AND deleted_on < SYSDATE-30;
  DBMS_OUTPUT.PUT_LINE('purged rows='||SQL%ROWCOUNT);
  COMMIT;
END;
/
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- (8) Bulk FORALL with SAVE EXCEPTIONS on order_lines (e.g., price adjust)
--------------------------------------------------------------------------------
DECLARE
  TYPE t_lines IS TABLE OF orders_line.line_id%TYPE;
  v_lines t_lines := t_lines(10011, 99999, 10012); -- one non-existent
  errors EXCEPTION; PRAGMA EXCEPTION_INIT(errors, -24381);
BEGIN
  BEGIN
    FORALL i IN 1..v_lines.COUNT SAVE EXCEPTIONS
      UPDATE orders_line SET price_each = price_each*1.05, line_total=ROUND(qty*(price_each*1.05),2)
      WHERE line_id = v_lines(i);
  EXCEPTION
    WHEN errors THEN
      DBMS_OUTPUT.PUT_LINE('bulk errors='||SQL%BULK_EXCEPTIONS.COUNT);
  END;
  COMMIT;
END;
/
--------------------------------------------------------------------------------
-- End of File
--------------------------------------------------------------------------------
