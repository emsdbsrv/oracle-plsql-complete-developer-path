SET SERVEROUTPUT ON SIZE UNLIMITED;

--------------------------------------------------------------------------------
-- Assignment – Session 093: Statement-Level Execution
-- Format:
--   • 10 tasks focused on designing and understanding statement-level triggers.
--   • Each task includes a fully-commented solution block.
--   • To practice: copy the solution, remove leading '--', and run it.
--------------------------------------------------------------------------------


/*********************************
 Q1 – AFTER UPDATE (statement-level) – Simple log line
 Task:
   Create a statement-level AFTER UPDATE trigger on tg_employees that prints
   a simple DBMS_OUTPUT message indicating that an update occurred.
*********************************/
-- SOLUTION:
-- CREATE OR REPLACE TRIGGER trg_emp_stmt_au_log_simple
-- AFTER UPDATE ON tg_employees
-- BEGIN
--   DBMS_OUTPUT.PUT_LINE('Statement-level: tg_employees updated.');
-- END;
-- /
--------------------------------------------------------------------------------


/*********************************
 Q2 – BEFORE DELETE (statement-level) – Prevent deletes on Sunday
 Task:
   Block ANY DELETE on tg_employees if today is Sunday (regardless of rows).
*********************************/
-- SOLUTION:
-- CREATE OR REPLACE TRIGGER trg_emp_stmt_bd_no_sunday
-- BEFORE DELETE ON tg_employees
-- DECLARE
--   v_day VARCHAR2(3);
-- BEGIN
--   v_day := TO_CHAR(SYSDATE,'DY');
--   IF v_day = 'SUN' THEN
--     RAISE_APPLICATION_ERROR(-33101,'DELETE not allowed on Sunday.');
--   END IF;
-- END;
-- /
--------------------------------------------------------------------------------


/*********************************
 Q3 – AFTER INSERT (statement-level) – Count inserted rows indirectly
 Task:
   There is no direct row count inside a statement-level trigger. However, you
   can compare table count before and after a batch to estimate growth.
   For this exercise, simply write a trigger that prints the total number of
   rows after an INSERT statement.
*********************************/
-- SOLUTION:
-- CREATE OR REPLACE TRIGGER trg_emp_stmt_ai_count
-- AFTER INSERT ON tg_employees
-- DECLARE
--   v_cnt PLS_INTEGER;
-- BEGIN
--   SELECT COUNT(*) INTO v_cnt FROM tg_employees;
--   DBMS_OUTPUT.PUT_LINE('Total rows after INSERT statement = '||v_cnt);
-- END;
-- /
--------------------------------------------------------------------------------


/*********************************
 Q4 – BEFORE UPDATE (statement-level) – Maintenance window example
 Task:
   Similar to the lesson, restrict ALL updates to the employees table to a
   weekday night window between 22:00 and 23:00.
*********************************/
-- SOLUTION:
-- CREATE OR REPLACE TRIGGER trg_emp_stmt_bu_weeknight
-- BEFORE UPDATE ON tg_employees
-- DECLARE
--   v_day  VARCHAR2(3);
--   v_hour VARCHAR2(2);
-- BEGIN
--   v_day  := TO_CHAR(SYSDATE,'DY');
--   v_hour := TO_CHAR(SYSDATE,'HH24');
--
--   -- Allow Mon–Fri only, between 22:00 and 23:00
--   IF v_day IN ('MON','TUE','WED','THU','FRI') THEN
--     IF NOT (v_hour BETWEEN '22' AND '23') THEN
--       RAISE_APPLICATION_ERROR(
--         -33102,
--         'Updates allowed only between 22:00 and 23:00 on weekdays.'
--       );
--     END IF;
--   ELSE
--     RAISE_APPLICATION_ERROR(
--       -33103,
--       'Updates not allowed on weekends.'
--     );
--   END IF;
-- END;
-- /
--------------------------------------------------------------------------------


/*********************************
 Q5 – AFTER DELETE (statement-level) – Store summary in audit table
 Task:
   Create a simple table stmt_delete_summary(emp_table VARCHAR2, deleted_on DATE).
   Then, create a statement-level AFTER DELETE trigger on tg_employees that
   inserts a single row into stmt_delete_summary.
*********************************/
-- SOLUTION:
-- CREATE TABLE stmt_delete_summary (
--   summary_id NUMBER GENERATED BY DEFAULT AS IDENTITY,
--   table_name VARCHAR2(30),
--   deleted_on DATE
-- );
-- /
-- CREATE OR REPLACE TRIGGER trg_emp_stmt_ad_summary
-- AFTER DELETE ON tg_employees
-- BEGIN
--   INSERT INTO stmt_delete_summary(table_name, deleted_on)
--   VALUES('TG_EMPLOYEES', SYSDATE);
-- END;
-- /
--------------------------------------------------------------------------------


/*********************************
 Q6 – AFTER INSERT OR UPDATE (statement-level) – Generic last-changed info
 Task:
   Create a table stmt_last_change(table_name VARCHAR2, last_changed_on DATE).
   Then create a statement-level trigger that updates this info whenever an
   INSERT or UPDATE happens on tg_employees.
*********************************/
-- SOLUTION:
-- CREATE TABLE stmt_last_change (
--   table_name      VARCHAR2(30) PRIMARY KEY,
--   last_changed_on DATE
-- );
-- /
-- CREATE OR REPLACE TRIGGER trg_emp_stmt_aiu_last_change
-- AFTER INSERT OR UPDATE ON tg_employees
-- BEGIN
--   MERGE INTO stmt_last_change t
--   USING (SELECT 'TG_EMPLOYEES' AS table_name FROM dual) s
--   ON (t.table_name = s.table_name)
--   WHEN MATCHED THEN
--     UPDATE SET t.last_changed_on = SYSDATE
--   WHEN NOT MATCHED THEN
--     INSERT (table_name, last_changed_on)
--     VALUES ('TG_EMPLOYEES', SYSDATE);
-- END;
-- /
--------------------------------------------------------------------------------


/*********************************
 Q7 – BEFORE INSERT (statement-level) – Simple audit who is inserting
 Task:
   Create a BEFORE INSERT statement-level trigger that only logs the user name
   once per INSERT statement into DBMS_OUTPUT.
*********************************/
-- SOLUTION:
-- CREATE OR REPLACE TRIGGER trg_emp_stmt_bi_log_user
-- BEFORE INSERT ON tg_employees
-- BEGIN
--   DBMS_OUTPUT.PUT_LINE('User '||USER||' is inserting into tg_employees.');
-- END;
-- /
--------------------------------------------------------------------------------


/*********************************
 Q8 – AFTER UPDATE (statement-level) – Track how often table is updated
 Task:
   Create a table stmt_update_counter (table_name VARCHAR2, update_count NUMBER).
   Then write an AFTER UPDATE statement-level trigger that increments the
   counter for tg_employees each time an UPDATE runs.
*********************************/
-- SOLUTION:
-- CREATE TABLE stmt_update_counter (
--   table_name   VARCHAR2(30) PRIMARY KEY,
--   update_count NUMBER
-- );
-- /
-- CREATE OR REPLACE TRIGGER trg_emp_stmt_au_inc_counter
-- AFTER UPDATE ON tg_employees
-- BEGIN
--   MERGE INTO stmt_update_counter t
--   USING (SELECT 'TG_EMPLOYEES' AS table_name FROM dual) s
--   ON (t.table_name = s.table_name)
--   WHEN MATCHED THEN
--     UPDATE SET t.update_count = NVL(t.update_count,0) + 1
--   WHEN NOT MATCHED THEN
--     INSERT (table_name, update_count)
--     VALUES ('TG_EMPLOYEES', 1);
-- END;
-- /
--------------------------------------------------------------------------------


/*********************************
 Q9 – AFTER INSERT (statement-level) – Demonstrate no :NEW for each row
 Task:
   In comments, explain why statement-level triggers cannot access per-row
   :NEW and :OLD directly. Then create an AFTER INSERT statement-level trigger
   that simply prints a message explaining this fact.
*********************************/
-- SOLUTION (comments + trigger):
-- Explanation:
--   • Statement-level triggers fire once per DML statement.
--   • They do not iterate per row, so :NEW and :OLD behave differently and are
--     not intended for row-by-row logic.
--   • Use row-level triggers when per-row details are needed.
--
-- CREATE OR REPLACE TRIGGER trg_emp_stmt_ai_explain
-- AFTER INSERT ON tg_employees
-- BEGIN
--   DBMS_OUTPUT.PUT_LINE(
--     'Statement-level trigger: no per-row :NEW/:OLD available here.'
--   );
-- END;
-- /
--------------------------------------------------------------------------------


/*********************************
 Q10 – BEFORE UPDATE (statement-level) – Soft lock pattern
 Task:
   Implement a BEFORE UPDATE statement-level trigger that blocks updates if
   a global parameter table indicates that the employees table is in a
   "locked" state.
   Hint: create table global_params(key VARCHAR2(30), value VARCHAR2(30)).
*********************************/
-- SOLUTION:
-- CREATE TABLE global_params (
--   param_key   VARCHAR2(30) PRIMARY KEY,
--   param_value VARCHAR2(30)
-- );
-- /
-- -- Example seed row:
-- -- INSERT INTO global_params(param_key, param_value)
-- -- VALUES('TG_EMP_LOCK','OFF');
-- -- COMMIT;
-- /
-- CREATE OR REPLACE TRIGGER trg_emp_stmt_bu_soft_lock
-- BEFORE UPDATE ON tg_employees
-- DECLARE
--   v_lock_status VARCHAR2(30);
-- BEGIN
--   SELECT param_value
--   INTO   v_lock_status
--   FROM   global_params
--   WHERE  param_key = 'TG_EMP_LOCK';
--
--   IF UPPER(v_lock_status) = 'ON' THEN
--     RAISE_APPLICATION_ERROR(
--       -33110,
--       'Updates on tg_employees are currently locked by configuration.'
--     );
--   END IF;
-- EXCEPTION
--   WHEN NO_DATA_FOUND THEN
--     NULL; -- If no parameter row, treat as unlocked
-- END;
-- /
--------------------------------------------------------------------------------

-- End of Assignment – Session 093
--------------------------------------------------------------------------------
